---
description: 
globs: 
alwaysApply: true
---
# Project Guidelines and Instructions

## Core Documentation
The project's comprehensive documentation is located in the `quizzer_documentation/Core Documentation/` directory. This documentation includes:
- Project overview and architecture
- User interface design guidelines
- Database schema and data models
- API documentation
- Testing procedures
- Deployment guidelines

All development should reference and follow the guidelines specified in the core documentation. If there are conflicts in the documentation they should be brought to my attention so they can be corrected.

## Core Philosophy
- Prioritize offline functionality and local development over cloud dependencies
- Treat education as a social good, not a commodity
- Maintain user privacy, data protection, and student autonomy as fundamental rights
- Focus on long-term maintainability and sustainability over short-term convenience
- Build modular, maintainable systems with minimal external dependencies

## Technical Architecture
- Design for offline-first operation with proper data synchronization
- Implement local data storage solutions with encryption
- Use open-source technologies when possible
- Avoid vendor lock-in and third-party service dependencies
- Build modular, maintainable systems

## Code Style and Formatting
- Follow Flutter's official style guide (https://dart.dev/guides/language/effective-dart/style)
- Use 4 spaces for indentation
- Keep lines under 80 characters
- Use trailing commas in multi-line parameter lists
- Use `const` constructors and `late` instead of nullable types when appropriate
- Prefer single quotes for strings
- Organize files with functions at the top, followed by a full-width separator line, then widgets
- Use full-width separator comment (e.g., `// ==========================================`) to separate functions from widgets
- Three full-width separator comments should be used
- Use shorter separator comment (e.g., `// ------------------------------------------`) between individual functions and widgets
- Example file structure:
  ```dart
  // Functions
  void functionOne() { ... }
  // ------------------------------------------
  void functionTwo() { ... }
  // ------------------------------------------
  
  // ==========================================
  
  // Widgets
  class WidgetOne extends StatelessWidget { ... }
  // ------------------------------------------
  class WidgetTwo extends StatelessWidget { ... }
  ```

## UI Guidelines
### General Layout Rules
- All UI elements should have uniform height
- Height of UI elements should be of a maximum of 25px and scale to the height of the screen
- Width of UI elements should not exceed the width of the logo
- Maintain consistent spacing between elements (8px minimum)
- Use proper padding around content (16px minimum)

### Color Scheme
- Primary background color: Color(0xFF0A1929)
- Secondary background color: Color(0xFF1E2A3A)
- Accent color: Color(0xFF4CAF50)
- Text color: Colors.white
- Hint color: Colors.grey
- Error color: Colors.red

### Typography
- Use consistent font sizes across the application
- Headers: 24px
- Subheaders: 20px
- Body text: 16px
- Small text: 14px
- Maintain proper contrast ratios for accessibility

### Button Design
- All buttons should follow a consistent style
- Primary buttons should use the accent color
- Secondary buttons should use the secondary background color
- Buttons should have proper padding (16px horizontal, 8px vertical)
- Buttons should include proper hover and active states
- Icon buttons should maintain a 1:1 aspect ratio
- Maximum icon size should be 25px

### Form Elements
- All input fields should have consistent styling
- Use proper validation feedback
- Show clear error messages
- Include proper loading states
- Maintain consistent spacing between form elements
- Use proper label placement and alignment

### Navigation
- Navigation elements should be clearly visible
- Use consistent icons for navigation
- Maintain proper spacing between navigation items
- Include proper active state indicators
- Ensure navigation is accessible on all screen sizes

### Responsive Design
- Design for mobile-first approach
- Use proper breakpoints for different screen sizes
- Ensure content is readable on all devices
- Maintain proper spacing on different screen sizes
- Use proper scaling for images and icons

### Animation and Transitions
- Use smooth animations for state changes
- Keep animations under 300ms
- Use proper easing functions
- Maintain consistent animation patterns
- Ensure animations don't interfere with usability

### Error Handling
- Show clear error messages
- Provide proper feedback for user actions
- Include proper loading states
- Maintain consistent error message styling
- Ensure error messages are accessible

### Accessibility
- Maintain proper contrast ratios
- Use proper semantic HTML
- Include proper ARIA labels
- Ensure keyboard navigation is possible
- Support screen readers

### Documentation Requirements
Each UI page documentation should include:
1. Clear purpose statement
2. Rule of thumb section with specific UI guidelines
3. Detailed interface elements section
4. Buttons section with specific locations and icons
5. Functionality description
6. User experience notes
7. Implementation notes
8. Technical dependencies
9. Proper cross-references to other documentation

## Architecture Guidelines
- Follow Clean Architecture principles
- Keep business logic separate from UI
- Use dependency injection and proper state management
- Keep widgets small and focused
- Implement proper error handling and data synchronization

## Testing
- Write comprehensive tests (unit, widget, integration) with >80% coverage
- Test offline functionality, data sync, and edge cases

## Security and Privacy
- Never hardcode sensitive information (use environment variables)
- Implement proper authentication and data encryption
- Validate all user input and follow secure coding practices
- Ensure user consent and clear data usage policies
- Implement proper data retention and protection measures

## Performance Guidelines
- Optimize widget rebuilds and use const constructors
- Implement proper caching and minimize network calls
- Optimize offline data access and synchronization
- Profile and optimize critical paths
- Minimize memory allocations in hot paths
- Use appropriate data structures for performance-critical operations

## Error Handling
- Follow fail-fast methodology: crash on error rather than hide it
- Use asserts and validation to ensure data matches exact expectations
- Avoid try-catch blocks unless absolutely necessary for external operations (cases where this is necessary is for network calls where there might be no clean way to handle this)
- Validate all data structures and types before use
- Throw errors immediately when data doesn't match expected format
- Example: If a function like `load_tutorial_question` returns null or malformed data, throw an error immediately rather than attempting to handle invalid data
- Use strong typing and null safety to catch errors at compile time
- Log errors with sufficient context for debugging
- Handle offline/online transitions explicitly with clear error states
- Everything should be logged no matter how insignificant, all actions the program takes should be documented through the logger.
- For logging use the logging functions defined in the backend/quizzer_logging.dart


## Code Review Checklist
- [ ] Code follows style guide and architecture principles
- [ ] Tests are present and passing with good coverage
- [ ] Security and privacy measures are implemented
- [ ] Performance is optimized and error handling is robust
- [ ] Offline functionality and data sync are working
- [ ] User autonomy and data protection are respected

## AI Assistant Guidelines
- Suggest improvements and point out potential issues
- Provide clear explanations for suggestions
- Consider performance, security, and maintainability
- Respect user privacy and autonomy
- Focus on long-term sustainability and offline functionality
- Avoid suggesting third-party dependencies
- Create TODO comments at the top of files when suggesting improvements, with clear descriptions of the suggested changes
- Never delete or remove existing features and code unless explicitly instructed or absolutely necessary
- Focus on writing individual functions and making changes within single files
- Avoid making sweeping changes across multiple files unless specifically requested 


Global widgets are in the global/ directory
global database is in the global/ directory

Please use common sense

You will not just randomly create new class objects and devices without properly searching the codebase first
