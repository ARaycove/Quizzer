import 'dart:convert';
import 'dart:io';
import 'dart:math';

// ==========================================
// Test Data Generation Script for Select-All-That-Apply (Even/Odd)
// ==========================================

void main() async {
  final List<Map<String, dynamic>> allQuestions = [];
  final Random random = Random();
  const String moduleName = 'Is Even Or Odd'; // Updated module name
  const String questionType = 'select_all_that_apply';
  const int totalQuestions = 100;
  const int optionsCount = 6; // Aim for 6 options
  const int minNumber = 1;
  const int maxNumber = 100;

  print('Generating $totalQuestions questions for module: $moduleName...');

  for (int i = 0; i < totalQuestions; i++) {
    final bool askForEven = i % 2 == 0; // Alternate between even and odd
    final String questionText = askForEven
        ? "Select all the EVEN numbers."
        : "Select all the ODD numbers.";
    final String answerText = askForEven
        ? "Even numbers are divisible by 2."
        : "Odd numbers are not divisible by 2.";

    final Set<int> optionsSet = {}; // Use a Set to ensure unique options

    // Generate unique random options
    while (optionsSet.length < optionsCount) {
      final int randomOption = random.nextInt(maxNumber) + minNumber; // 1 to 100
      optionsSet.add(randomOption);
    }

    // Convert set to list for ordered indices
    final List<int> optionsNumbers = optionsSet.toList();

    // Determine correct indices based on the question type (even/odd)
    final List<int> correctIndices = [];
    for (int index = 0; index < optionsNumbers.length; index++) {
      final int number = optionsNumbers[index];
      final bool isEven = number % 2 == 0;
      if ((askForEven && isEven) || (!askForEven && !isEven)) {
        correctIndices.add(index);
      }
    }
    // Ensure we actually have some correct answers to select!
    // If by chance all generated numbers were odd when asking for even (or vice-versa),
    // regenerate this question.
    if (correctIndices.isEmpty) {
       print('Warning: Regenerating question $i as no correct options were generated by chance.');
       i--; // Decrement i to redo this iteration
       continue;
    }

    // Format options list for JSON
    final List<Map<String, dynamic>> optionsListFormatted = optionsNumbers.map((option) {
      return {'type': 'text', 'content': option.toString()};
    }).toList();

    // Create the question map
    final Map<String, dynamic> questionMap = {
      'moduleName': moduleName,
      'questionType': questionType,
      'questionElements': [
        {'type': 'text', 'content': questionText}
      ],
      'answerElements': [
        {'type': 'text', 'content': answerText}
      ],
      'options': optionsListFormatted, // Use the formatted list of maps
      'indexOptionsThatApply': correctIndices, // The list of correct indices
    };

    allQuestions.add(questionMap);
  }

  print('Successfully generated ${allQuestions.length} questions.');

  // Define output path (relative to project root)
  final String outputDir = 'runtime_cache';
  final String outputFilePath = '$outputDir/number_properties_questions.json';

  // Ensure directory exists
  final Directory dir = Directory(outputDir);
  if (!await dir.exists()) {
    print('Creating directory: $outputDir');
    await dir.create(recursive: true);
  }

  // Encode to JSON
  final JsonEncoder encoder = JsonEncoder.withIndent('  '); // Pretty print
  final String jsonString = encoder.convert(allQuestions);

  // Write to file
  final File outputFile = File(outputFilePath);
  try {
    await outputFile.writeAsString(jsonString);
    print('Successfully wrote questions to: $outputFilePath');
  } catch (e) {
    // This try-catch is acceptable for external operations like file I/O
    print('Error writing questions to file: $e');
  }
}
